CREATE SCHEMA cte_inline;
SET search_path TO cte_inline;
SET citus.next_shard_id TO 1960000;
CREATE TABLE test_table (key int, value text, other_value jsonb);
SELECT create_distributed_table ('test_table', 'key');
 create_distributed_table 
--------------------------
 
(1 row)

SET client_min_messages TO DEBUG;
-- Citus should not inline this CTE because otherwise it cannot
-- plan the query
WITH cte_1 AS (SELECT * FROM test_table)
SELECT
	*, row_number() OVER ()
FROM
	cte_1;
DEBUG:  Skipped inlining the cte cte_1 because if inlined, Citus planner might error with: could not run distributed query because the window function that is used cannot be pushed down
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan 1_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan 1 query after replacing subqueries and CTEs: SELECT key, value, other_value, row_number() OVER () AS row_number FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('1_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value | row_number 
-----+-------+-------------+------------
(0 rows)

-- the cte can be inlined because the unsupported
-- part of the query (subquery in WHERE clause)
-- doesn't access the cte
WITH cte_1 AS (SELECT * FROM test_table)
SELECT
	count(*)
FROM
	cte_1
WHERE
	key IN (
			SELECT
				row_number() OVER () as row_n
			FROM
				test_table WHERE key = 1
			);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Distributed planning for a fast-path router query
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DETAIL:  distribution column value: 1
DEBUG:  generating subplan 3_1 for subquery SELECT row_number() OVER () AS row_n FROM cte_inline.test_table WHERE (key OPERATOR(pg_catalog.=) 1)
DEBUG:  Plan 3 query after replacing subqueries and CTEs: SELECT count(*) AS count FROM (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table) cte_1 WHERE (key OPERATOR(pg_catalog.=) ANY (SELECT intermediate_result.row_n FROM read_intermediate_result('3_1'::text, 'binary'::citus_copy_format) intermediate_result(row_n bigint)))
DEBUG:  Router planner cannot handle multi-shard select queries
 count 
-------
     0
(1 row)

-- a similar query as the above, and this time the planning
-- fails, but it fails because the subquery in WHERE clause
-- cannot be planned by Citus
WITH cte_1 AS (SELECT * FROM test_table)
SELECT
	count(*)
FROM
	cte_1
WHERE
	key IN (
			SELECT
				row_number() OVER () as row_n
			FROM
				test_table
			);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
ERROR:  could not run distributed query because the window function that is used cannot be pushed down
HINT:  Window functions are supported in two ways. Either add an equality filter on the distributed tables' partition column or use the window functions with a PARTITION BY clause containing the distribution column
-- even if the CTE is not used immediately
-- on a query that Citus could not support,
-- it skips inlining, otherwise the planner
-- might fail
WITH cte_1 AS
  (SELECT *
   FROM test_table)
SELECT row_number() OVER ()
FROM
  (SELECT *
   FROM cte_1) AS foo;
DEBUG:  Skipped inlining the cte cte_1 because if inlined, Citus planner might error with: could not run distributed query because the window function that is used cannot be pushed down
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan 7_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan 7 query after replacing subqueries and CTEs: SELECT row_number() OVER () AS row_number FROM (SELECT cte_1.key, cte_1.value, cte_1.other_value FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('7_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1) foo
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 row_number 
------------
(0 rows)

-- a little more complicated query tree
-- Citus can inline top_cte, because when inlined
-- it can be planned by Citus. However, citus doesn't
-- inline cte_1 because when inlined, Citus cannot
-- plan the query
WITH top_cte AS
  (SELECT *
   FROM test_table)
SELECT *
FROM top_cte,
  (WITH cte_1 AS
     (SELECT *
      FROM test_table) SELECT row_number() OVER ()
   FROM
     (SELECT *
      FROM cte_1) AS foo) AS bar;
DEBUG:  CTE top_cte is going to be inlined via distributed planning
DEBUG:  Skipped inlining the cte cte_1 because if inlined, Citus planner might error with: could not run distributed query because the window function that is used cannot be pushed down
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan 9_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DEBUG:  generating subplan 9_2 for subquery SELECT row_number() OVER () AS row_number FROM (SELECT cte_1.key, cte_1.value, cte_1.other_value FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('9_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1) foo
DEBUG:  Plan 9 query after replacing subqueries and CTEs: SELECT top_cte.key, top_cte.value, top_cte.other_value, bar.row_number FROM (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table) top_cte, (SELECT intermediate_result.row_number FROM read_intermediate_result('9_2'::text, 'binary'::citus_copy_format) intermediate_result(row_number bigint)) bar
DEBUG:  Router planner cannot handle multi-shard select queries
 key | value | other_value | row_number 
-----+-------+-------------+------------
(0 rows)

-- CTE is used inside a subquery in WHERE clause
-- so, should not be inlined
WITH cte_1 AS
  (SELECT *
   FROM test_table)
SELECT count(*)
FROM test_table
WHERE KEY IN
    (SELECT row_number() OVER () AS KEY
     FROM
       (SELECT *,
               random()
        FROM
          (SELECT *
           FROM cte_1) AS foo) AS bar);
DEBUG:  Skipped inlining the cte cte_1 because if inlined, Citus planner might error with: could not run distributed query because the window function that is used cannot be pushed down
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan 12_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DEBUG:  generating subplan 12_2 for subquery SELECT row_number() OVER () AS key FROM (SELECT foo.key, foo.value, foo.other_value, random() AS random FROM (SELECT cte_1.key, cte_1.value, cte_1.other_value FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('12_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1) foo) bar
DEBUG:  Plan 12 query after replacing subqueries and CTEs: SELECT count(*) AS count FROM cte_inline.test_table WHERE (key OPERATOR(pg_catalog.=) ANY (SELECT intermediate_result.key FROM read_intermediate_result('12_2'::text, 'binary'::citus_copy_format) intermediate_result(key bigint)))
DEBUG:  Router planner cannot handle multi-shard select queries
 count 
-------
     0
(1 row)

-- cte_1 is used inside another CTE, but still
-- should not be inlined because it is finally
-- used in an unsupported query
WITH cte_1 AS
  (SELECT *
   FROM test_table)
SELECT row_number() OVER () AS KEY  FROM (
  WITH cte_2 AS (SELECT *, random()
     FROM (SELECT *,random() FROM cte_1) as foo)
SELECT *, random() FROM cte_2) as bar;
DEBUG:  Skipped inlining the cte cte_1 because if inlined, Citus planner might error with: could not run distributed query because the window function that is used cannot be pushed down
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan 15_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan 15_2 for CTE cte_2: SELECT key, value, other_value, random, random() AS random FROM (SELECT cte_1.key, cte_1.value, cte_1.other_value, random() AS random FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('15_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1) foo
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DEBUG:  Plan 15 query after replacing subqueries and CTEs: SELECT row_number() OVER () AS key FROM (SELECT cte_2.key, cte_2.value, cte_2.other_value, cte_2.random, cte_2.random_1 AS random, random() AS random FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value, intermediate_result.random, intermediate_result.random_1 AS random FROM read_intermediate_result('15_2'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb, random double precision, random_1 double precision)) cte_2(key, value, other_value, random, random_1)) bar(key, value, other_value, random, random_1, random_2)
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key 
-----
(0 rows)

-- in this example, cte_2 can be inlined, because it is not used
-- on any query that Citus cannot plan. However, cte_1 should not be
-- inlined, because it is used with an unsupported window function
WITH cte_1 AS (SELECT * FROM test_table),
     cte_2 AS (select * from test_table)
SELECT
	*
FROM
	(SELECT *, row_number() OVER () FROM cte_1) as foo
		JOIN
	cte_2
		ON (true);
DEBUG:  Skipped inlining the cte cte_1 because if inlined, Citus planner might error with: could not run distributed query because the window function that is used cannot be pushed down
DEBUG:  CTE cte_2 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan 18_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DEBUG:  generating subplan 18_2 for subquery SELECT key, value, other_value, row_number() OVER () AS row_number FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('18_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1
DEBUG:  Plan 18 query after replacing subqueries and CTEs: SELECT foo.key, foo.value, foo.other_value, foo.row_number, cte_2.key, cte_2.value, cte_2.other_value FROM ((SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value, intermediate_result.row_number FROM read_intermediate_result('18_2'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb, row_number bigint)) foo JOIN (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table) cte_2 ON (true))
DEBUG:  Router planner cannot handle multi-shard select queries
 key | value | other_value | row_number | key | value | other_value 
-----+-------+-------------+------------+-----+-------+-------------
(0 rows)

-- unreferenced CTEs are just ignored
-- by Citus/Postgres
WITH a AS (SELECT * FROM test_table)
SELECT
	*, row_number() OVER ()
FROM
	test_table
WHERE
	key = 1;
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DETAIL:  distribution column value: 1
 key | value | other_value | row_number 
-----+-------+-------------+------------
(0 rows)

-- router queries are affected by the distributed
-- cte inlining. In this example, although it is
-- a router query, Citus decides not to inline the CTE
-- because of the window function
WITH a AS (SELECT * FROM test_table)
SELECT
	*, row_number() OVER ()
FROM
	a
WHERE
	key = 1;
DEBUG:  Skipped inlining the cte a because if inlined, Citus planner might error with: could not run distributed query because the window function that is used cannot be pushed down
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DETAIL:  distribution column value: 1
 key | value | other_value | row_number 
-----+-------+-------------+------------
(0 rows)

-- router queries are affected by the distributed
-- cte inlining as well
WITH a AS (SELECT * FROM test_table)
SELECT
	count(*)
FROM
	a
WHERE
	key = 1;
DEBUG:  CTE a is going to be inlined via distributed planning
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DETAIL:  distribution column value: 1
 count 
-------
     0
(1 row)

-- citus should not inline the CTE because it is used multiple times
WITH cte_1 AS (SELECT * FROM test_table)
SELECT
	count(*)
FROM
	cte_1 as first_entry
		JOIN
	cte_1 as second_entry
		USING (key);
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan 24_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan 24 query after replacing subqueries and CTEs: SELECT count(*) AS count FROM ((SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('24_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) first_entry JOIN (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('24_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) second_entry USING (key))
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 count 
-------
     0
(1 row)

-- ctes with volatile functions are not
-- inlined
WITH cte_1 AS (SELECT *, random() FROM test_table)
SELECT
	*
FROM
	cte_1;
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan 26_1 for CTE cte_1: SELECT key, value, other_value, random() AS random FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan 26 query after replacing subqueries and CTEs: SELECT key, value, other_value, random FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value, intermediate_result.random FROM read_intermediate_result('26_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb, random double precision)) cte_1
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value | random 
-----+-------+-------------+--------
(0 rows)

-- cte_1 should be able to inlined even if
-- it is used one level below
WITH cte_1 AS (SELECT * FROM test_table)
SELECT
	*
FROM
(
	WITH ct2 AS (SELECT * FROM cte_1)
	SELECT * FROM ct2
) as foo;
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE ct2 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 key | value | other_value 
-----+-------+-------------
(0 rows)

-- a similar query, but there is also
-- one more cte, which relies on the previous
-- CTE
WITH cte_1 AS (SELECT * FROM test_table)
SELECT
	*
FROM
(
	WITH cte_2 AS (SELECT * FROM cte_1),
		 cte_3 AS (SELECT * FROM cte_2)
	SELECT * FROM cte_3
) as foo;
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_2 is going to be inlined via distributed planning
DEBUG:  CTE cte_3 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 key | value | other_value 
-----+-------+-------------
(0 rows)

-- inlined CTE contains a reference to outer query
-- should be fine (because we pushdown the whole query)
SELECT *
	FROM
	  (SELECT *
	   FROM test_table) AS test_table_cte
	JOIN LATERAL
	  (WITH bar AS  (SELECT *
	      FROM test_table
	      WHERE key = test_table_cte.key)
	  	SELECT *
	   FROM
	      bar
	   LEFT JOIN test_table u2 ON u2.key = bar.key) AS foo ON TRUE;
DEBUG:  CTE bar is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 key | value | other_value | key | value | other_value | key | value | other_value 
-----+-------+-------------+-----+-------+-------------+-----+-------+-------------
(0 rows)

-- inlined CTE contains a reference to outer query
-- should be fine (even if the recursive planning fails
-- to recursively plan the query)
SELECT *
	FROM
	  (SELECT *
	   FROM test_table) AS test_table_cte
	JOIN LATERAL
	  (WITH bar AS  (SELECT *
	      FROM test_table
	      WHERE key = test_table_cte.key)
	  	SELECT *
	   FROM
	      bar
	   LEFT JOIN test_table u2 ON u2.key = bar.value::int) AS foo ON TRUE;
DEBUG:  CTE bar is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  skipping recursive planning for the subquery since it contains references to outer queries
DEBUG:  skipping recursive planning for the subquery since it contains references to outer queries
DEBUG:  skipping recursive planning for the subquery since it contains references to outer queries
ERROR:  complex joins are only supported when all distributed tables are joined on their distribution columns with equal operator
-- inlined CTE can recursively planned later, that's the decision
-- recursive planning makes
-- LIMIT 5 in cte2 triggers recusrive planning, after cte inlining
WITH cte_1 AS (SELECT * FROM test_table)
SELECT
	*
FROM
(
	WITH ct2 AS (SELECT * FROM cte_1 LIMIT 5)
	SELECT * FROM ct2
) as foo;
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE ct2 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  push down of limit count: 5
DEBUG:  generating subplan 32_1 for subquery SELECT key, value, other_value FROM (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table) cte_1 LIMIT 5
DEBUG:  Plan 32 query after replacing subqueries and CTEs: SELECT key, value, other_value FROM (SELECT ct2.key, ct2.value, ct2.other_value FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('32_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) ct2) foo
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value 
-----+-------+-------------
(0 rows)

-- all nested CTEs can be inlinied
WITH cte_1  AS (
  WITH cte_1 AS (
    WITH cte_1 AS (
      WITH cte_1 AS (
        WITH cte_1 AS (
          WITH cte_1 AS (
            WITH cte_1 AS (SELECT count(*), key FROM  test_table GROUP BY key)
            			   SELECT * FROM cte_1)
          SELECT * FROM cte_1 WHERE key = 1)
        SELECT * FROM cte_1 WHERE key = 2)
      SELECT * FROM cte_1 WHERE key = 3)
    SELECT * FROM cte_1 WHERE key = 4)
  SELECT * FROM cte_1 WHERE key = 5)
SELECT * FROM cte_1 WHERE key = 6;
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DETAIL:  distribution column value: 1
 count | key 
-------+-----
(0 rows)

-- ctes can be inlined even if they are used
-- in set operations
WITH cte_1 AS (SELECT * FROM test_table),
	 cte_2 AS (SELECT * FROM test_table)
(SELECT * FROM cte_1 EXCEPT SELECT * FROM test_table)
UNION
(SELECT * FROM cte_2);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_2 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan 35_1 for subquery SELECT key, value, other_value FROM (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table) cte_1
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan 35_2 for subquery SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan 35_3 for subquery SELECT key, value, other_value FROM (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table) cte_2
DEBUG:  Plan 35 query after replacing subqueries and CTEs: (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('35_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb) EXCEPT SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('35_2'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) UNION SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('35_3'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value 
-----+-------+-------------
(0 rows)

-- inlinining enforces the same restrictions
-- when the cte is used in set operations
-- so, cte_1 is not going to be inlined
WITH cte_1 AS (SELECT * FROM test_table),
	 cte_2 AS (SELECT * FROM test_table)
(SELECT *, (SELECT 1) FROM cte_1 EXCEPT SELECT *, 1 FROM test_table)
UNION
(SELECT *, 1 FROM cte_2);
DEBUG:  Skipped inlining the cte cte_1 because if inlined, Citus planner might error with: could not run distributed query with subquery outside the FROM, WHERE and HAVING clauses
DEBUG:  CTE cte_2 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan 39_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DEBUG:  generating subplan 39_2 for subquery SELECT key, value, other_value, (SELECT 1) FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('39_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan 39_3 for subquery SELECT key, value, other_value, 1 FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan 39_4 for subquery SELECT key, value, other_value, 1 FROM (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table) cte_2
DEBUG:  Plan 39 query after replacing subqueries and CTEs: (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value, intermediate_result."?column?" FROM read_intermediate_result('39_2'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb, "?column?" integer) EXCEPT SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value, intermediate_result."?column?" FROM read_intermediate_result('39_3'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb, "?column?" integer)) UNION SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value, intermediate_result."?column?" FROM read_intermediate_result('39_4'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb, "?column?" integer)
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value | ?column? 
-----+-------+-------------+----------
(0 rows)

-- cte_1 is not safe to inline, because after inlining
-- it'd be in a query tree where there is a query that is
-- not supported by Citus
-- cte_2 is on another queryTree, should be fine
WITH cte_1 AS (SELECT * FROM test_table),
	 cte_2 AS (SELECT * FROM test_table)
(SELECT *, (SELECT key FROM cte_1) FROM test_table)
UNION
(SELECT *, 1 FROM cte_2);
DEBUG:  Skipped inlining the cte cte_1 because if inlined, Citus planner might error with: could not run distributed query with subquery outside the FROM, WHERE and HAVING clauses
DEBUG:  CTE cte_2 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan 44_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
ERROR:  could not run distributed query with subquery outside the FROM, WHERE and HAVING clauses
HINT:  Consider using an equality filter on the distributed table's partition column.
-- after inlining CTEs, the query becomes
-- subquery pushdown with set operations
WITH cte_1 AS (SELECT * FROM test_table),
	 cte_2 AS (SELECT * FROM test_table)
SELECT * FROM
(
	SELECT * FROM cte_1
		UNION
	SELECT * FROM cte_2
) as bar;
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_2 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 key | value | other_value 
-----+-------+-------------
(0 rows)

-- cte LEFT JOIN subquery should only work
-- when CTE is inlined, as Citus currently
-- doesn't know how to handle intermediate
-- results in the outer parts of outer
-- queries
WITH cte AS (SELECT * FROM test_table)
SELECT
	count(*)
FROM
	cte LEFT JOIN test_table USING (key);
DEBUG:  CTE cte is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count 
-------
     0
(1 row)

-- the CTEs are very simple, so postgres
-- can pull-up the subqueries after inlining
-- the CTEs, and the query that we send to workers
-- becomes a join between two tables
WITH cte_1 AS (SELECT key FROM test_table),
	 cte_2 AS (SELECT key FROM test_table)
SELECT
	count(*)
FROM
	cte_1 JOIN cte_2 USING (key);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_2 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  join prunable for intervals [-2147483648,-1073741825] and [-1073741824,-1]
DEBUG:  join prunable for intervals [-2147483648,-1073741825] and [0,1073741823]
DEBUG:  join prunable for intervals [-2147483648,-1073741825] and [1073741824,2147483647]
DEBUG:  join prunable for intervals [-1073741824,-1] and [-2147483648,-1073741825]
DEBUG:  join prunable for intervals [-1073741824,-1] and [0,1073741823]
DEBUG:  join prunable for intervals [-1073741824,-1] and [1073741824,2147483647]
DEBUG:  join prunable for intervals [0,1073741823] and [-2147483648,-1073741825]
DEBUG:  join prunable for intervals [0,1073741823] and [-1073741824,-1]
DEBUG:  join prunable for intervals [0,1073741823] and [1073741824,2147483647]
DEBUG:  join prunable for intervals [1073741824,2147483647] and [-2147483648,-1073741825]
DEBUG:  join prunable for intervals [1073741824,2147483647] and [-1073741824,-1]
DEBUG:  join prunable for intervals [1073741824,2147483647] and [0,1073741823]
 count 
-------
     0
(1 row)

-- the following query is kind of interesting
-- During INSERT .. SELECT via coordinator,
-- Citus moves the CTEs into SELECT part, and plans/execute
-- the SELECT separately. Thus, fist_table_cte can be inlined
-- by Citus -- but not by Postgres
WITH fist_table_cte AS
  (SELECT * FROM test_table)
INSERT INTO test_table
            (key, value)
            SELECT
              key, value
            FROM
              fist_table_cte;
DEBUG:  distributed INSERT ... SELECT can only select from distributed tables
DEBUG:  Collecting INSERT ... SELECT results on coordinator
DEBUG:  CTE fist_table_cte is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
-- the following INSERT..SELECT is even more interesting
-- the CTE becomes
-- TODO: discuss with Marco, is there anything that we should
-- prevent this? Postgres doesn't inline CTEs in modification queries
-- but why?
INSERT INTO test_table
WITH fist_table_cte AS
  (SELECT * FROM test_table)
    SELECT
      key, value
    FROM
      fist_table_cte;
DEBUG:  CTE fist_table_cte is going to be inlined via distributed planning
DEBUG:  distributed statement: INSERT INTO cte_inline.test_table_1960000 AS citus_table_alias (key, value) SELECT key, value FROM (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table_1960000 test_table) fist_table_cte WHERE ((worker_hash(key) OPERATOR(pg_catalog.>=) '-2147483648'::integer) AND (worker_hash(key) OPERATOR(pg_catalog.<=) '-1073741825'::integer))
DEBUG:  distributed statement: INSERT INTO cte_inline.test_table_1960001 AS citus_table_alias (key, value) SELECT key, value FROM (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table_1960001 test_table) fist_table_cte WHERE ((worker_hash(key) OPERATOR(pg_catalog.>=) '-1073741824'::integer) AND (worker_hash(key) OPERATOR(pg_catalog.<=) '-1'::integer))
DEBUG:  distributed statement: INSERT INTO cte_inline.test_table_1960002 AS citus_table_alias (key, value) SELECT key, value FROM (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table_1960002 test_table) fist_table_cte WHERE ((worker_hash(key) OPERATOR(pg_catalog.>=) 0) AND (worker_hash(key) OPERATOR(pg_catalog.<=) 1073741823))
DEBUG:  distributed statement: INSERT INTO cte_inline.test_table_1960003 AS citus_table_alias (key, value) SELECT key, value FROM (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table_1960003 test_table) fist_table_cte WHERE ((worker_hash(key) OPERATOR(pg_catalog.>=) 1073741824) AND (worker_hash(key) OPERATOR(pg_catalog.<=) 2147483647))
DEBUG:  Plan is router executable
-- update/delete/modifying ctes
-- we don't support any cte inlining in modifications
-- queries and modifying CTEs
WITH cte_1 AS (SELECT * FROM test_table WHERE key > 1)
	DELETE FROM test_table WHERE key IN (SELECT key FROM cte_1);
DEBUG:  cannot push down this subquery
DETAIL:  CTEs in subqueries are currently unsupported
DEBUG:  generating subplan 53_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table WHERE (key OPERATOR(pg_catalog.>) 1)
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan 53 query after replacing subqueries and CTEs: DELETE FROM cte_inline.test_table WHERE (key OPERATOR(pg_catalog.=) ANY (SELECT cte_1.key FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('53_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1))
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
-- we don't inline CTEs if they are modifying CTEs
WITH cte_1 AS (DELETE FROM test_table RETURNING key)
SELECT * FROM cte_1;
DEBUG:  data-modifying statements are not supported in the WITH clauses of distributed queries
DEBUG:  generating subplan 55_1 for CTE cte_1: DELETE FROM cte_inline.test_table RETURNING key
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DEBUG:  Plan 55 query after replacing subqueries and CTEs: SELECT key FROM (SELECT intermediate_result.key FROM read_intermediate_result('55_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer)) cte_1
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key 
-----
(0 rows)

-- cte with column aliases
SELECT * FROM test_table,
(WITH cte_1 (x,y) AS (SELECT * FROM test_table),
     cte_2 (z,y) AS (SELECT value, other_value, key FROM test_table),
	 cte_3 (t,m) AS (SELECT z, y, key as cte_2_key FROM cte_2)
		SELECT * FROM cte_2, cte_3) as bar;
DEBUG:  CTE cte_3 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan 57_1 for CTE cte_2: SELECT value, other_value, key FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan 57 query after replacing subqueries and CTEs: SELECT test_table.key, test_table.value, test_table.other_value, bar.z, bar.y, bar.key, bar.t, bar.m, bar.cte_2_key FROM cte_inline.test_table, (SELECT cte_2.z, cte_2.y, cte_2.key, cte_3.t, cte_3.m, cte_3.cte_2_key FROM (SELECT intermediate_result.value AS z, intermediate_result.other_value AS y, intermediate_result.key FROM read_intermediate_result('57_1'::text, 'binary'::citus_copy_format) intermediate_result(value text, other_value jsonb, key integer)) cte_2, (SELECT cte_2_1.z AS t, cte_2_1.y AS m, cte_2_1.key AS cte_2_key FROM (SELECT intermediate_result.value AS z, intermediate_result.other_value AS y, intermediate_result.key FROM read_intermediate_result('57_1'::text, 'binary'::citus_copy_format) intermediate_result(value text, other_value jsonb, key integer)) cte_2_1) cte_3) bar
DEBUG:  Router planner cannot handle multi-shard select queries
 key | value | other_value | z | y | key | t | m | cte_2_key 
-----+-------+-------------+---+---+-----+---+---+-----------
(0 rows)

-- cte used in HAVING subquery just works fine
-- even if it is inlined
WITH cte_1 AS (SELECT max(key) as max FROM test_table)
SELECT
	key, count(*)
FROM
	test_table
GROUP BY
	key
HAVING
	(count(*) > (SELECT max FROM cte_1));
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan 59_1 for subquery SELECT max(key) AS max FROM cte_inline.test_table
DEBUG:  Plan 59 query after replacing subqueries and CTEs: SELECT key, count(*) AS count FROM cte_inline.test_table GROUP BY key HAVING (count(*) OPERATOR(pg_catalog.>) (SELECT cte_1.max FROM (SELECT intermediate_result.max FROM read_intermediate_result('59_1'::text, 'binary'::citus_copy_format) intermediate_result(max integer)) cte_1))
DEBUG:  Router planner cannot handle multi-shard select queries
 key | count 
-----+-------
(0 rows)

-- cte used in ORDER BY just works fine
-- even if it is inlined
WITH cte_1 AS (SELECT max(key) as max FROM test_table)
SELECT
	key
FROM
	test_table JOIN cte_1 ON (key = max)
ORDER BY
	cte_1.max;
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan 61_1 for subquery SELECT max(key) AS max FROM cte_inline.test_table
DEBUG:  Plan 61 query after replacing subqueries and CTEs: SELECT test_table.key FROM (cte_inline.test_table JOIN (SELECT intermediate_result.max FROM read_intermediate_result('61_1'::text, 'binary'::citus_copy_format) intermediate_result(max integer)) cte_1 ON ((test_table.key OPERATOR(pg_catalog.=) cte_1.max))) ORDER BY cte_1.max
DEBUG:  Router planner cannot handle multi-shard select queries
 key 
-----
(0 rows)

PREPARE inlined_cte_without_params AS
	WITH cte_1 AS (SELECT count(*) FROM test_table GROUP BY key)
	SELECT * FROM cte_1;
PREPARE inlined_cte_has_parameter_on_non_dist_key(int) AS
	WITH cte_1 AS (SELECT count(*) FROM test_table WHERE value::int = $1 GROUP BY key)
	SELECT * FROM cte_1;
PREPARE inlined_cte_has_parameter_on_dist_key(int) AS
	WITH cte_1 AS (SELECT count(*) FROM test_table WHERE key > $1 GROUP BY key)
	SELECT * FROM cte_1;
EXECUTE inlined_cte_without_params;
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count 
-------
(0 rows)

EXECUTE inlined_cte_without_params;
 count 
-------
(0 rows)

EXECUTE inlined_cte_without_params;
 count 
-------
(0 rows)

EXECUTE inlined_cte_without_params;
 count 
-------
(0 rows)

EXECUTE inlined_cte_without_params;
 count 
-------
(0 rows)

EXECUTE inlined_cte_without_params;
 count 
-------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_non_dist_key(1);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count 
-------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_non_dist_key(2);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count 
-------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_non_dist_key(3);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count 
-------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_non_dist_key(4);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count 
-------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_non_dist_key(5);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count 
-------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_non_dist_key(6);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count 
-------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_dist_key(1);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count 
-------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_dist_key(2);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count 
-------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_dist_key(3);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count 
-------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_dist_key(4);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count 
-------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_dist_key(5);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count 
-------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_dist_key(6);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count 
-------
(0 rows)

-- prevent DROP CASCADE to give notices
SET client_min_messages TO ERROR;
DROP SCHEMA cte_inline CASCADE;
